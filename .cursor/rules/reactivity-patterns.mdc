---
description: Patterns and best practices for working with reactive primitives in Signalis
---

# Reactivity Patterns & Best Practices

## Lazy vs. Eager Evaluation

### Derived Values (Lazy)

- **Never recompute on dependency change alone**
- Only recompute when `.value` is accessed
- Check if dependencies changed before recomputing
- See [packages/core/src/derived.ts](mdc:packages/core/src/derived.ts)

### Effects (Eager)

- **Recompute immediately on dependency change**
- Run callback as soon as any dependency updates
- Use for side effects, not for computing values
- See [packages/core/src/effect.ts](mdc:packages/core/src/effect.ts)

## Dependency Tracking

All dependency tracking flows through [packages/core/src/state.ts](mdc:packages/core/src/state.ts):

1. **Reading**: `markDependency()` called when `.value` is accessed
2. **Writing**: `markUpdates()` called when value changes
3. **Reacting**: `runReactions()` processes pending updates

## Observer Pattern

Reactive primitives maintain observer lists:

```typescript
_observers: Array<Derived<unknown> | Reaction> | null = null;
```

- Signals notify Derived values and Reactions
- Derived values notify their own observers
- Reactions trigger re-evaluation

## Equality Checking

Signals support custom equality functions:

```typescript
// Default: === comparison
const signal = createSignal(value);

// Custom equality (e.g., deep equality)
const signal = createSignal(value, isEqual);

// Always notify (volatile)
const signal = createSignal(value, false);
```

## Store Updates

Stores use an Immer-like API via the `update` function:

```typescript
update(store, (draft) => {
  draft.property = newValue;
  draft.array.push(item);
});
```

- Mutations are applied to the original store
- Updates trigger reactive notifications
- See [packages/core/src/update.ts](mdc:packages/core/src/update.ts)

## Resource Patterns

### Standalone Resource

```typescript
const resource = createResource(() => fetchData());
```

### Resource with Source

```typescript
const id = createSignal(null);
const resource = createResource(id, (id) => fetchData(id));
```

- Fetcher only runs when source is truthy
- Re-fetches when source changes

## React Integration

### Reactor HOC

The `reactor` HOC uses `Reaction.trap()` to create a reactive render context:

```typescript
export default reactor(MyComponent);
```

**How it works:**

1. Wraps component in a Proxy that intercepts function calls
2. Creates a `Reaction` instance that triggers `forceUpdate()` on dependency changes
3. Each render is wrapped in `Reaction.trap()` to establish tracking context
4. Signal reads **during render execution** are tracked automatically
5. When tracked signals change, the reaction fires and component re-renders

**Critical distinction:**

- ✅ **Tracked**: Signal reads during component render (JSX, render-time computations)
- ❌ **Not tracked**: Signal reads in event handlers, callbacks, async functions, or effects

```typescript
const App = reactor(() => {
  const count = useSignal(0);

  // ✅ Tracked - read during render
  return <div>{count.value}</div>;

  // ❌ Not tracked - read in event handler
  const handleClick = () => console.log(count.value);
});
```

See [packages/react/src/reactor.ts](mdc:packages/react/src/reactor.ts) for implementation details.

### Hooks

- `useSignal()`: Persists signal across renders using `useMemo`
- `useDerived()`: Persists derived using `useRef` + `useMemo`, supports mixed dependencies via deps array
- `useSignalEffect()`: Reactive effect with React lifecycle cleanup, uses `Reaction` internally

## Performance Considerations

1. **Minimize unnecessary computations**: Derived values won't recompute if dependencies haven't changed
2. **Batch updates**: Use `batch()` to group multiple signal updates
3. **Dispose effects**: Always clean up effects when no longer needed
