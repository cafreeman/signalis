# Signalis

Signalis is a lightweight library for reactivity influenced by @preact/signals, SolidJS, and reactively. It provides highly composable, highly performant primitives for building reactive programs.

## Overview

Signalis exposes a small set of reactive primitives:
- **Signals**: Writable reactive values
- **Derived**: Readonly computed values with lazy evaluation
- **Effects**: Reactive side-effect functions
- **Resources**: Async reactive values with loading/error states
- **Stores**: Proxy-based fine-grained reactive objects
- **Reaction**: Low-level reactive function primitive

The library uses a push-pull reactivity model where signals push notifications and derived values pull updates lazily.

## Packages

- `@signalis/core` - Core reactivity primitives (zero dependencies)
- `@signalis/react` - React integration (includes and re-exports all of core)

## Documentation Structure

### Getting Started
- [Installation](https://signalis.dev/guide/installation): Package installation for npm, pnpm, yarn
- [Quick Start](https://signalis.dev/guide/quick-start): 5-minute tutorial with counter examples
- [Core Concepts](https://signalis.dev/guide/core-concepts): Push-pull model, lazy evaluation, dependency tracking

### Core API (`@signalis/core`)
- [Signals](https://signalis.dev/core/signals): createSignal(), equality functions, notifier pattern
- [Derived](https://signalis.dev/core/derived): createDerived(), smart recomputation heuristic
- [Effects](https://signalis.dev/core/effects): createEffect(), cleanup patterns, disposal
- [Resources](https://signalis.dev/core/resources): createResource(), async data with sources
- [Stores](https://signalis.dev/core/stores): createStore(), update(), fine-grained reactivity
- [Utilities](https://signalis.dev/core/utilities): batch(), isSignal(), isDerived(), isReaction()

### React Integration (`@signalis/react`)
- [reactor HOC](https://signalis.dev/react/reactor): Automatic re-rendering via Proxy
- [useSignal](https://signalis.dev/react/use-signal): Component-scoped signals
- [useDerived](https://signalis.dev/react/use-derived): Computed values with mixed dependencies
- [useSignalEffect](https://signalis.dev/react/use-signal-effect): Effects with automatic signal tracking

### Examples
- [Stopwatch](https://signalis.dev/examples/stopwatch): Effects with cleanup, time-based reactivity, derived formatting
- [Todo List](https://signalis.dev/examples/todo-list): Stores, CRUD operations, filtering
- [Async Data](https://signalis.dev/examples/async-data): Resources, pagination, loading states
- [Composition](https://signalis.dev/examples/composition): Building reusable reactive primitives

## Key Concepts

### Push-Pull Model
- **Push phase**: Signals notify observers they're stale when changed
- **Pull phase**: Derived values only recompute when accessed
- Result: Lazy evaluation prevents unnecessary work

### Smart Recomputation
Derived values use a heuristic to minimize recomputation:
1. If direct dependencies changed → recompute immediately
2. If indirect dependencies changed → check direct dependencies first
3. If no actual change detected → return cached value

### Reactivity Rules
- **Signals**: Use for mutable state, read/write with `.value`
- **Derived**: Use for pure computations, automatically cache
- **Effects**: Use for side effects, run eagerly (not lazy)
- **Resources**: Use for async operations, built-in loading/error
- **Stores**: Use for nested objects, fine-grained property tracking

### React Integration
- Wrap components with `reactor()` to enable automatic re-rendering
- Use `useSignal()` for component-local signals (like useState)
- Use `useDerived()` for computed values with optional deps array
- Use `useSignalEffect()` for side effects with signal tracking

## TypeScript Support

Fully typed with strict TypeScript:
- Generic type parameters for all primitives
- Type inference for derived values
- Function overloads for different call patterns
- Private interface pattern for internal APIs

## Design Philosophy

1. **Lazy by default**: Derived values only compute when needed
2. **Composable**: Small primitives that combine well
3. **Performant**: Smart recomputation minimizes work
4. **Type-safe**: Full TypeScript support
5. **Zero dependencies**: Minimal footprint

## Common Patterns

- Counter: Basic signal usage
- Form validation: Derived values for errors
- API requests: Resources with loading states
- State management: Stores for nested objects
- Custom hooks: Composing primitives into reusable abstractions

## Installation

```bash
npm install @signalis/core        # Core only
npm install @signalis/react       # React (includes core)
```

## Links

- [GitHub Repository](https://github.com/cafreeman/signalis)
- [npm: @signalis/core](https://www.npmjs.com/package/@signalis/core)
- [npm: @signalis/react](https://www.npmjs.com/package/@signalis/react)
- [Full Documentation](https://signalis.dev/)
